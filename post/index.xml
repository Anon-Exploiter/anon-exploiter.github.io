<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Umar_0x01 – Pentester | Programmer | Your average sakurity guy ( ͡~ ͜ʖ ͡°)</title>
    
    
    
    <link>https://umar0x01.sh/post/</link>
    <description>Recent content in Posts on Umar_0x01 – Pentester | Programmer | Your average sakurity guy ( ͡~ ͜ʖ ͡°)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://umar0x01.sh/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PyCode Testing</title>
      <link>https://umar0x01.sh/post/pycode-testing/</link>
      <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://umar0x01.sh/post/pycode-testing/</guid>
      <description>
        
          &lt;img src=&#34;https://umar0x01.sh/img/getStatus.png&#34;/&gt;
          
        
        
        &lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Hello, friend?&amp;rdquo; That&amp;rsquo;s lame.
Maybe I should give you a name&amp;hellip;
But that&amp;rsquo;s a slippery slope.
You&amp;rsquo;re only in my head.
We have to remember that&amp;hellip;
Shit.
It&amp;rsquo;s actually happened.
I&amp;rsquo;m talking to an imaginary person.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;— Mr. Robot S01E01&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;GetStatus snippet&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;

#!/usr/bin/python3

&amp;#34;&amp;#34;&amp;#34;
For printing the status of both down, up and non-existent hosts/URLs (has no DNS records or the instance/application/server hosting the URL/host went down). Wrote this since I wasn&amp;#39;t able to find this functionality in some commonly known open-source scripts. In some cases, one needs the hosts which are down too! (e.g. elasticbeanstalk applications, etc.)

chmod &amp;#43;x getStatus
sudo mv getStatus /usr/bin/

- For fetching URLs/host which are only up
	cat urlsList | getStatus

	cat urlsList | getStatus --down

- Note:
	The inputted urls shouldn&amp;#39;t have http/https appended, the format should only be: www.google.com || google.com
&amp;#34;&amp;#34;&amp;#34;

import requests
from bs4 import BeautifulSoup
import sys
import concurrent.futures
import dns.resolver

cyan 	= &amp;#34;\033[0;96m&amp;#34;
green 	= &amp;#34;\033[0;92m&amp;#34;
white 	= &amp;#34;\033[0;97m&amp;#34;
red 	= &amp;#34;\033[0;91m&amp;#34;
blue 	= &amp;#34;\033[0;94m&amp;#34;
yellow 	= &amp;#34;\033[0;33m&amp;#34;
magenta = &amp;#34;\033[0;35m&amp;#34;

def fetchUrls():
	userInput 	= sys.stdin
	urls 		= []

	for lines in userInput:
		lines 	= lines.strip()
		if lines != &amp;#34;&amp;#34;:
			urls.append(lines)

	return(urls)

def returnRequestStatus(url, spacing):
	requestTimeout  = 0.5
	reqUrl 			= f&amp;#34;http://{url}&amp;#34;

	try:
		response 	= requests.get(reqUrl, timeout=requestTimeout, allow_redirects=True)
		respCode 	= str(response.status_code)
		respText 	= response.text
		respLen 	= str(len(respText))

		try:
			title 	= BeautifulSoup(respText, &amp;#39;html.parser&amp;#39;).find_all(&amp;#39;title&amp;#39;)[0].text.strip()
			print(&amp;#34;{}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;{}}{} | {}{}{}&amp;#34;.format(yellow, respCode, white,
				magenta, respLen, white,
				green, &amp;#34;UP&amp;#34;, white,
				cyan, url, spacing, white,
				blue, title, white,
			))

		except IndexError:
			print(&amp;#34;{}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;{}}{} |&amp;#34;.format(yellow, respCode, white,
				magenta, respLen, white,
				green, &amp;#34;UP&amp;#34;, white,
				cyan, url, spacing, white,
			))

	except requests.exceptions.ConnectionError:
		try:
			if sys.argv[1] != &amp;#39;--down&amp;#39;:
				pass

		except IndexError:
			print(&amp;#34;{}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;{}}{} |&amp;#34;.format(red, &amp;#34;0&amp;#34;,  white,
				red, &amp;#34;0&amp;#34;, white,
				red, &amp;#34;DOWN&amp;#34;, white,
				red, url, spacing, white,
			))

def getDNSRecords(host):
	answers 	= &amp;#34;&amp;#34;

	try:
		resolver 	= dns.resolver.Resolver()
		resolver.timeout = 1
		resolver.lifetime = 1

		answers 	= resolver.query(host,&amp;#39;CNAME&amp;#39;)[::-1][0].target
		# print(answers)

	except dns.resolver.NXDOMAIN: 	# Has no domain records
		answers 	= host
		pass

	except dns.resolver.NoAnswer: 	# Has A/other records, not CNAME
		pass

	except dns.resolver.NoNameservers: # Wasn&amp;#39;t able to resolve due to some reason
		pass

	except dns.exception.Timeout: 	# Timeout in case it can&amp;#39;t reach the server
		pass

	return([host, str(answers)])

def main():
	processes 		= 50
	urls 			= fetchUrls()

	hosts 		= []
	cnames 		= []

	# for url in urls:
	# 	getDNSRecords(url)

	with concurrent.futures.ProcessPoolExecutor(max_workers=processes) as executor:
		for results in executor.map(getDNSRecords, urls):
			if results[1] != &amp;#34;&amp;#34;:
				hosts.append(results[0])
				cnames.append(results[1])

	len1 	= max(len(_len) for _len in hosts) &amp;#43; 8
	len2 	= max(len(_len) for _len in cnames) &amp;#43; 8
	bar 	= &amp;#34;-&amp;#34; * (len1 &amp;#43; len2)

	print(bar)
	print(&amp;#34;{:&amp;lt;{}} | {}&amp;#34;.format(&amp;#34;Host&amp;#34;, (len1), &amp;#34;Resolved CNAME Record&amp;#34;))
	print(bar)

	for host, cname in zip(hosts, cnames):
		print(&amp;#34;{}{:&amp;lt;{}}{} | {}{}&amp;#34;.format(cyan, host, len1, white,
			green, cname &amp;#43; white
		))

	print(bar)

	print(&amp;#34;\n\n\n\n\n\n\n&amp;#34;)

	biggestLength 	= max(len(_len) for _len in cnames) &amp;#43; 8
	bar 			= &amp;#34;-&amp;#34; * (80 &amp;#43; biggestLength &amp;#43; 20)
	print(bar)
	print(&amp;#34;{:&amp;lt;20} | {:&amp;lt;20} | {:&amp;lt;20} | {:&amp;lt;{}} | {}&amp;#34;.format(&amp;#34;Response Code&amp;#34;, &amp;#34;Response Length&amp;#34;, &amp;#34;Status&amp;#34;, &amp;#34;Host&amp;#34;, biggestLength, &amp;#34;Title&amp;#34;))
	print(bar)

	# for hosts in cnames:
	# 	returnRequestStatus(hosts, biggestLength)

	with concurrent.futures.ProcessPoolExecutor(max_workers=processes) as executor:
		executor.map(returnRequestStatus, cnames, [biggestLength] * len(cnames))
	
	print(bar)

if __name__ == &amp;#39;__main__&amp;#39;:
	main()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;



        
        </description>
    </item>
    
    <item>
      <title>SUID Enumeration/Exploitation - The Automated Way!</title>
      <link>https://umar0x01.sh/post/suid-enumeration/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://umar0x01.sh/post/suid-enumeration/</guid>
      <description>
        
          &lt;img src=&#34;https://umar0x01.sh/img/screenshot_10.png&#34;/&gt;
          
        
        
        &lt;h2 id=&#34;what-the-heck-is-suid-enum&#34;&gt;What the heck is SUID ENUM!?&lt;/h2&gt;
&lt;p&gt;Are you also tired of &lt;strong&gt;finding &amp;amp;&amp;amp; enumerating possibly exploitable SUID binaries&lt;/strong&gt; like me!? Only to miss the ones you were going to &lt;em&gt;escalate your priviliges&lt;/em&gt; with?&lt;/p&gt;
&lt;p&gt;Welp, I just happened to develop a solution: &lt;a href=&#34;https://github.com/Anon-Exploiter/SUID3NUM&#34;&gt;SUID 3NUM&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(Self promote, I will! - Yoda)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://umar0x01.sh/img/screenshot_10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;A (not-so-cool-as-it-seems-like) standalone script supporting both &lt;strong&gt;python2&lt;/strong&gt; &amp;amp; &lt;strong&gt;python3&lt;/strong&gt; to find out all SUID binaries in a linux box and do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List all Default SUID Binaries (which ship with linux/aren&amp;rsquo;t exploitable)&lt;/li&gt;
&lt;li&gt;List all Custom Binaries (which don&amp;rsquo;t ship with packages/vanilla installation)&lt;/li&gt;
&lt;li&gt;List all Custom binaries found in GTFO Bin&amp;rsquo;s list (This is where things get interesting)&lt;/li&gt;
&lt;li&gt;Try and auto-exploit found custom SUID binaries which won&amp;rsquo;t impact any of the machine&amp;rsquo;s binaries&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;---description-goes-here---&#34;&gt;&amp;lt;!&amp;ndash; Description goes here &amp;ndash;&amp;gt;&lt;/h3&gt;
&lt;p&gt;Many of the times while doing &lt;strong&gt;Vulnhub&lt;/strong&gt;, &lt;strong&gt;HTB&lt;/strong&gt; &amp;amp;&amp;amp; other &lt;strong&gt;vulnerable machines&lt;/strong&gt;, I stumbled upon &lt;em&gt;SUID binaries&lt;/em&gt; in the box, I didn&amp;rsquo;t have any method to seperate exploitable SUID binaries from those default SUID binaries of the system.&lt;/p&gt;
&lt;p&gt;Fortunately, &lt;a href=&#34;https://github.com/rebootuser/LinEnum&#34;&gt;LinEnum&lt;/a&gt; seperated vulnerable binaries which were present in list of GTFO Bins and presented it nicely in a new section named &lt;code&gt;Interesting SUID Bins&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://umar0x01.sh/img/troll_gifs/awesome.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;awesome-isnt-it&#34;&gt;Awesome, isn&amp;rsquo;t it?&lt;/h4&gt;
&lt;p&gt;By this time, you&amp;rsquo;ll be asking yourself, then why da heck I made this blog post and that script, &lt;strong&gt;If LinEum is so cool!?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ndash;&lt;/p&gt;
&lt;h5 id=&#34;lets-get-on-that-now&#34;&gt;Lets get on that now:&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://umar0x01.sh/img/troll_gifs/finally.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if a binary &lt;strong&gt;isn&amp;rsquo;t&lt;/strong&gt; in GTFO&amp;rsquo;s bins list and is still exploitable?&lt;/li&gt;
&lt;li&gt;What If the sysadmin renamed the exploitable binary (like &lt;em&gt;cp, find, cat, vim, iftop etc.&lt;/em&gt;) to something else?&lt;/li&gt;
&lt;li&gt;What if there&amp;rsquo;s a custom C/C++ compiled binary having SUID bit set on it?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You&amp;rsquo;ll definitely miss that one binary through which you were going to escalate yourself to the next level. We all know, when LinEnum shows interesting SUID bins list, nobody ever looks at the whole list of the SUID binaries!&lt;/p&gt;
&lt;p&gt;Also, LinEnum and other enumeration scripts only print SUID binaries &amp;amp; GTFO Binaries, they don&amp;rsquo;t seperate default binaries from custom binaries, which lead to severe head banging in walls for 3-4 hours when you can&amp;rsquo;t escalate priviliges :)&lt;/p&gt;
&lt;h5 id=&#34;solution&#34;&gt;Solution:&lt;/h5&gt;
&lt;p&gt;The above issues struck me to create a script which seperates both custom SUID bit-set binaries and default binaries, cross-match custom binaries with GTFO Bin&amp;rsquo;s binaries list. Further, go-ahead, try and auto-exploit them (only in case, they aren&amp;rsquo;t going to &lt;strong&gt;alter any files&lt;/strong&gt; on the system!)&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Initializing Script&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python suid3num.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Doing Auto Exploitation of Exploitable SUID binaries&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python suid3num.py -e
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;screenshotsworking&#34;&gt;Screenshots/Working&lt;/h3&gt;
&lt;p&gt;Here are some screenshots describing output of the script:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h4 id=&#34;suid-enumeration-without--e&#34;&gt;SUID Enumeration (without -e)&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/273928&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/273928.svg&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;auto-exploitation-of-suid-binaries-with--e&#34;&gt;Auto-Exploitation of SUID Binaries (with -e)&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/273929&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/273929.svg&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;faq&#34;&gt;FAQ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Can I run it on OSCP labs/exam machines?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;According to some folks, as long as you aren&amp;rsquo;t using &lt;code&gt;-e&lt;/code&gt; flag, its completely fine! Also, I myself used it in mine, so no probs!&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;you-like-it-now-dont-you---ʖ-&#34;&gt;You like it now, don&amp;rsquo;t you? ( ͡° ͜ʖ ͡°)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://umar0x01.sh/img/troll_gifs/hello_pepe.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;future-todos&#34;&gt;Future ToDo(s):&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Get a Life ¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯&lt;/li&gt;
&lt;li&gt;Make improvements in default SUID binaries list&lt;/li&gt;
&lt;li&gt;Create scripts for &lt;code&gt;linux capabilities&lt;/code&gt; and for binaries one can run with &lt;code&gt;sudo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;aightimmaheadout&#34;&gt;./aightImmaHeadOut&lt;/h3&gt;
&lt;p&gt;Hope, you like the script, you can find me &lt;a href=&#34;https://twitter.com/syed__umar&#34;&gt;@syed__umar&lt;/a&gt; on twitter!&lt;/p&gt;
&lt;p&gt;See ya, later!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://umar0x01.sh/img/troll_gifs/dissapear.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;

        
        </description>
    </item>
    
  </channel>
</rss>