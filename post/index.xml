<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Umar_0x01 – Pentester | Programmer | Your average sakurity guy ( ͡~ ͜ʖ ͡°)</title>
    
    
    
    <link>https://umar0x01.sh/post/</link>
    <description>Recent content in Posts on Umar_0x01 – Pentester | Programmer | Your average sakurity guy ( ͡~ ͜ʖ ͡°)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://umar0x01.sh/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PyCode Testing</title>
      <link>https://umar0x01.sh/post/pycode-testing/</link>
      <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://umar0x01.sh/post/pycode-testing/</guid>
      <description>
        
          &lt;img src=&#34;https://umar0x01.sh/img/hello-friend.jpg&#34;/&gt;
          
        
        
        &lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Hello, friend?&amp;rdquo; That&amp;rsquo;s lame.
Maybe I should give you a name&amp;hellip;
But that&amp;rsquo;s a slippery slope.
You&amp;rsquo;re only in my head.
We have to remember that&amp;hellip;
Shit.
It&amp;rsquo;s actually happened.
I&amp;rsquo;m talking to an imaginary person.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;— Mr. Robot S01E01&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;GetStatus snippet&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

&amp;#34;&amp;#34;&amp;#34;
For printing the status of both down, up and non-existent hosts/URLs (has no DNS records or the instance/application/server hosting the URL/host went down). Wrote this since I wasn&amp;#39;t able to find this functionality in some commonly known open-source scripts. In some cases, one needs the hosts which are down too! (e.g. elasticbeanstalk applications, etc.)

chmod &amp;#43;x getStatus
sudo mv getStatus /usr/bin/

- For fetching URLs/host which are only up
	cat urlsList | getStatus

	cat urlsList | getStatus --down

- Note:
	The inputted urls shouldn&amp;#39;t have http/https appended, the format should only be: www.google.com || google.com
&amp;#34;&amp;#34;&amp;#34;

import requests
from bs4 import BeautifulSoup
import sys
import concurrent.futures
import dns.resolver

cyan 	= &amp;#34;\033[0;96m&amp;#34;
green 	= &amp;#34;\033[0;92m&amp;#34;
white 	= &amp;#34;\033[0;97m&amp;#34;
red 	= &amp;#34;\033[0;91m&amp;#34;
blue 	= &amp;#34;\033[0;94m&amp;#34;
yellow 	= &amp;#34;\033[0;33m&amp;#34;
magenta = &amp;#34;\033[0;35m&amp;#34;

def fetchUrls():
	userInput 	= sys.stdin
	urls 		= []

	for lines in userInput:
		lines 	= lines.strip()
		if lines != &amp;#34;&amp;#34;:
			urls.append(lines)

	return(urls)

def returnRequestStatus(url, spacing):
	requestTimeout  = 0.5
	reqUrl 			= f&amp;#34;http://{url}&amp;#34;

	try:
		response 	= requests.get(reqUrl, timeout=requestTimeout, allow_redirects=True)
		respCode 	= str(response.status_code)
		respText 	= response.text
		respLen 	= str(len(respText))

		try:
			title 	= BeautifulSoup(respText, &amp;#39;html.parser&amp;#39;).find_all(&amp;#39;title&amp;#39;)[0].text.strip()
			print(&amp;#34;{}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;{}}{} | {}{}{}&amp;#34;.format(yellow, respCode, white,
				magenta, respLen, white,
				green, &amp;#34;UP&amp;#34;, white,
				cyan, url, spacing, white,
				blue, title, white,
			))

		except IndexError:
			print(&amp;#34;{}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;{}}{} |&amp;#34;.format(yellow, respCode, white,
				magenta, respLen, white,
				green, &amp;#34;UP&amp;#34;, white,
				cyan, url, spacing, white,
			))

	except requests.exceptions.ConnectionError:
		try:
			if sys.argv[1] != &amp;#39;--down&amp;#39;:
				pass

		except IndexError:
			print(&amp;#34;{}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;20}{} | {}{:&amp;lt;{}}{} |&amp;#34;.format(red, &amp;#34;0&amp;#34;,  white,
				red, &amp;#34;0&amp;#34;, white,
				red, &amp;#34;DOWN&amp;#34;, white,
				red, url, spacing, white,
			))

def getDNSRecords(host):
	answers 	= &amp;#34;&amp;#34;

	try:
		resolver 	= dns.resolver.Resolver()
		resolver.timeout = 1
		resolver.lifetime = 1

		answers 	= resolver.query(host,&amp;#39;CNAME&amp;#39;)[::-1][0].target
		# print(answers)

	except dns.resolver.NXDOMAIN: 	# Has no domain records
		answers 	= host
		pass

	except dns.resolver.NoAnswer: 	# Has A/other records, not CNAME
		pass

	except dns.resolver.NoNameservers: # Wasn&amp;#39;t able to resolve due to some reason
		pass

	except dns.exception.Timeout: 	# Timeout in case it can&amp;#39;t reach the server
		pass

	return([host, str(answers)])

def main():
	processes 		= 50
	urls 			= fetchUrls()

	hosts 		= []
	cnames 		= []

	# for url in urls:
	# 	getDNSRecords(url)

	with concurrent.futures.ProcessPoolExecutor(max_workers=processes) as executor:
		for results in executor.map(getDNSRecords, urls):
			if results[1] != &amp;#34;&amp;#34;:
				hosts.append(results[0])
				cnames.append(results[1])

	len1 	= max(len(_len) for _len in hosts) &amp;#43; 8
	len2 	= max(len(_len) for _len in cnames) &amp;#43; 8
	bar 	= &amp;#34;-&amp;#34; * (len1 &amp;#43; len2)

	print(bar)
	print(&amp;#34;{:&amp;lt;{}} | {}&amp;#34;.format(&amp;#34;Host&amp;#34;, (len1), &amp;#34;Resolved CNAME Record&amp;#34;))
	print(bar)

	for host, cname in zip(hosts, cnames):
		print(&amp;#34;{}{:&amp;lt;{}}{} | {}{}&amp;#34;.format(cyan, host, len1, white,
			green, cname &amp;#43; white
		))

	print(bar)

	print(&amp;#34;\n\n\n\n\n\n\n&amp;#34;)

	biggestLength 	= max(len(_len) for _len in cnames) &amp;#43; 8
	bar 			= &amp;#34;-&amp;#34; * (80 &amp;#43; biggestLength &amp;#43; 20)
	print(bar)
	print(&amp;#34;{:&amp;lt;20} | {:&amp;lt;20} | {:&amp;lt;20} | {:&amp;lt;{}} | {}&amp;#34;.format(&amp;#34;Response Code&amp;#34;, &amp;#34;Response Length&amp;#34;, &amp;#34;Status&amp;#34;, &amp;#34;Host&amp;#34;, biggestLength, &amp;#34;Title&amp;#34;))
	print(bar)

	# for hosts in cnames:
	# 	returnRequestStatus(hosts, biggestLength)

	with concurrent.futures.ProcessPoolExecutor(max_workers=processes) as executor:
		executor.map(returnRequestStatus, cnames, [biggestLength] * len(cnames))
	
	print(bar)

if __name__ == &amp;#39;__main__&amp;#39;:
	main()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;



        
        </description>
    </item>
    
  </channel>
</rss>